---
import { getCollection } from "astro:content";
import { File, Folder } from "lucide-react";
import Layout from "@/layouts/Layout.astro";
import CompletionBadge from "@/components/CompletionBadge.astro";
import TagBadge from "@/components/TagBadge.astro";

export async function getStaticPaths() {
  const notes = await getCollection("notes");
  const folders = new Set<string>();

  for (const note of notes) {
    const parts = note.id.split("/");
    for (let i = 0; i < parts.length; i++) {
      const folder = parts.slice(0, i).join("/");
      folders.add(folder);
    }
  }

  return Array.from(folders).map((folderPath) => ({
    params: { path: folderPath + "/" },
  }));
}

const { path = "" } = Astro.params;
const splitPath = path === "" ? [] : path?.split("/");

const notes = await getCollection("notes");

// Notes directly inside the current folder
const currentNotes = notes.filter((note) => {
  const parts = note.id.split("/");
  return parts.slice(0, -1).join("/") === path;
});

// Immediate subfolders inside the current folder
const subfolders = new Set<string>();
for (const note of notes) {
  const parts = note.id.split("/");
  if (
    parts.length > splitPath.length + 1 &&
    parts.slice(0, splitPath.length).join("/") === path
  ) {
    subfolders.add(parts[splitPath.length]);
  }
}

type folderEntry = {
  type: "folder";
  name: string;
  href: string;
};
type noteEntry = {
  type: "note";
  name: string;
  href: string;
  tags: string[];
  complete: boolean;
};

// Notes in current or nested folders
const items: (folderEntry | noteEntry)[] = [
  ...Array.from(subfolders)
    .map(
      (name) =>
        ({
          type: "folder",
          name,
          href: `/notes/${[...splitPath, name].join("/")}/`,
        }) as folderEntry,
    )
    .sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase())),
  ...currentNotes
    .map(
      (note) =>
        ({
          type: "note",
          name:
            note.filePath?.split("/").pop()?.replace(".md", "") ??
            note.id.split("/").pop() ??
            "",
          href: `/notes/${note.id}/`,
          tags: note.data.tags || [],
          complete: note.data.complete,
        }) as noteEntry,
    )
    .sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase())),
];
---

<Layout>
  <div class="flex-1 max-w-5xl overflow-y-auto mx-auto">
    <h1 class="text-3xl font-bold mb-4">{path || "Notes"}</h1>
    <div class="rounded-md border">
      <table class="table-auto border-collapse w-full">
        <thead>
          <tr class="text-left">
            <th class="py-2 px-4 w-1/4">Name</th>
            <th class="py-2 px-4 w-14/24">Tags</th>
            <th class="py-2 px-4 w-1/6">Complete</th>
          </tr>
        </thead>
        <tbody>
          {
            items.map((item) => (
              <tr class="border-t">
                <td class="py-2 px-4">
                  <div class="flex flex-row items-center gap-2">
                    {item.type === "folder" ? <Folder className="w-4" /> : <File className="w-4" />}
                    <a
                      href={item.href}
                      class="hover:text-primary hover:underline"
                    >
                      {item.name}
                    </a>
                  </div>
                </td>
                <td class="py-2 px-4">
                  {item.type === "note" && (
                    <div class="flex flex-wrap gap-1 overflow-x-auto">
                      {item.tags.length > 0
                        ? item.tags.map((tag) => <TagBadge tag={tag} />)
                        : "-"}
                    </div>
                  )}
                </td>
                <td class="py-2 px-4">
                  {item.type === "note" && (
                    <CompletionBadge completion={item.complete} />
                  )}
                </td>
              </tr>
            ))
          }
        </tbody>
      </table>
    </div>
  </div>
</Layout>
